# NSMutableDictionary+REST.framework

Rails'ish REST support for Objective-C's `NSMutableDictionary` (libxml2 SAX2 based - yes it works with iPhone/iPad).

Provides intuitive asynchronous and synchronous interface.

    // Example usage:
    NSString *stringUrl = @"http://github.com/api/v2/xml/user/search/chacon";
    NSURL *url = [NSURL URLWithString: stringUrl];
    NSLog(@"%@", [NSMutableDictionary dictionaryWithRESTContentsOfURL: url]);
    
    // ...will output something like this:
    {
      users = (
        {
          created = "2008-04-26T15:37:59Z";
          followers = 1;
          fullname = "Mirek Rusin";
          id = "user-8561";
          language = "C++";
          location = London;
          name = mirek;
          pushed = "2010-05-23T21:16:50.272Z";
          repos = 8;
          score = "15.604";
          type = user;
          username = mirek;
        },
        {
          created = "2009-10-16T16:38:48Z";
          followers = 0;
          fullname = "Mirek Rusin";
          id = "user-140734";
          language = Ruby;
          location = London;
          name = mirekrusin;
          pushed = "2010-05-24T02:16:19.737Z";
          repos = 1;
          score = "2.978005";
          type = user;
          username = mirekrusin;
        },
        {
          created = "2010-04-22T14:28:13Z";
          followers = 0;
          fullname = "Mirek Mencel";
          id = "user-249912";
          language = "";
          location = "Wroc\U0142aw";
          name = mirekm;
          pushed = "2010-05-25T02:20:23.464Z";
          repos = 0;
          score = "2.978005";
          type = user;
          username = mirekm;
        }
      );
    }
    
Can you spot rails'ish way? The XML looks like this:

    <users type="array"> 
      <user> 
        <name>mirek</name> 
        <location>London</location> 
        <followers type="integer">1</followers> 
        <fullname>Mirek Rusin</fullname> 
        <language>C++</language> 
        <username>mirek</username> 
        <id>user-8561</id> 
        <repos type="integer">8</repos> 
        <type>user</type> 
        <pushed>2010-05-23T21:16:50.272Z</pushed> 
        <score type="float">15.603998</score> 
        <created>2008-04-26T15:37:59Z</created> 
      </user> 
      <user> 
        <name>mirekrusin</name> 
        <location>London</location> 
        <followers type="integer">0</followers> 
        <fullname>Mirek Rusin</fullname> 
        <language>Ruby</language> 
        <username>mirekrusin</username> 
        <id>user-140734</id> 
        <repos type="integer">1</repos> 
        <type>user</type> 
        <pushed>2010-05-24T02:16:19.737Z</pushed> 
        <score type="float">2.9780054</score> 
        <created>2009-10-16T16:38:48Z</created> 
      </user> 
      <user> 
        <name>mirekm</name> 
        <location>Wroc&#322;aw</location> 
        <followers type="integer">0</followers> 
        <fullname>Mirek Mencel</fullname> 
        <language></language> 
        <username>mirekm</username> 
        <id>user-249912</id> 
        <repos type="integer">0</repos> 
        <type>user</type> 
        <pushed>2010-05-25T02:20:23.464Z</pushed> 
        <score type="float">2.9780054</score> 
        <created>2010-04-22T14:28:13Z</created> 
      </user> 
    </users>

## Async and sync at the same time?

Yes, look at this code:

    NSString *stringUrl = @"http://github.com/api/v2/xml/user/search/mirek";
    NSURL *url = [NSURL URLWithString: stringUrl];

    // Delegate gets objects asynchronously and constructor returns synchronously
    NSDictionary *users = [NSMutableDictionary dictionaryWithRESTContentsOfURL: url
                                                                      delegate: [[UserPrinter alloc] init]];
                                                                      
    // Above method returned synchronously
    printf("Total users: %i\n", (int)[[users objectForKey: @"users"] count]);

...where a `delegate` object is defined as:

    @interface UserPrinter : NSObject
    @end

    @implementation UserPrinter

    - (void) didFinishElement: (id) element withPath: (NSString *) path {
      if ([path isEqualToString: @"/users/user"]) {
      
        // Yielding users asynchronously
        NSDictionary *user = (NSDictionary *)element;
        printf("- %s (%s)\n", [[user objectForKey: @"fullname"] UTF8String],
                              [[user objectForKey: @"username"] UTF8String]);
      }
    }

    @end
    
## Simple POST support

To generate simple HTTP POST from your dictionary:

    // Using `users` from the example above...
    printf("%s\n", [[[[users objectForKey: @"users"] objectAtIndex: 0] HTTPPostData] UTF8String]);
    
    // ...will output:
    id=user-8561&repos=8&pushed=2010-05-23T21%3A16%3A50.272Z&type=user&location=London\
    &language=C%2B%2B&username=mirek&created=2008-04-26T15%3A37%3A59Z\
    &fullname=Mirek%20Rusin&followers=1&score=15.65372&name=mirek

...next on the list: `multipart/form-data` support.

## License

© 2010 Mirek Rusin, Released under the Apache License, Version 2.0
http://www.apache.org/licenses/LICENSE-2.0

## Authors

* Mirek Rusin <mirek [at] me [dot] com>
